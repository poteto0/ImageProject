import cv2import numpy as npimport mathimport loggingfrom scipy import ndimageimport imageProcessing as ip# 画像の傾き検出# @return 水平からの傾き角度""" 画像を回転する    ① 画像からオブジェクトを一つずつ抽出    ② オブジェクトを取得して1次関数フィッティング(直線フィッティング)    ③ 画像から直線成分を取得して水平方向に対する傾きを取得し、回転    (※)長さを測るために3次関数フィッティングを行う際に縦方向の個体で誤作動があるので    横方向にすることが画像回転の目的"""def rotateImage(img,fname):    """--- 画像の前処理 ---"""    bin_img = ip.binarization(img, fname) # 二値化    mor_img = ip.morphology(bin_img, fname) # モルフォロジー変換    msk_img = cv2.merge((mor_img, mor_img, mor_img)) # マスクのチャンネル数を3に    res = cv2.bitwise_and(img,msk_img)        """　全てのオブジェクトを抽出(サイズ) """    # ラベリング #    # 画像内の連結領域を抽出する(ラベリング)    nLabels, labelImages, data, center = cv2.connectedComponentsWithStats(mor_img)     # 連結部分を1つずつ抽出 #    for i in range(1,nLabels,1): # ラベル数を取得 ＊背景である0を除く        target_lb_id = i # ターゲットID        tobjx = data[target_lb_id, 0] # (対象の)x座標        tobjy = data[target_lb_id, 1] # (対象の)y座標        tobjw = data[target_lb_id, 2] # (対象の)幅        tobjh = data[target_lb_id, 3] # (対象の)長さ(高さ)               """ 一定サイズ以上のオブジェクトを切り出して回転            =>  ノイズ除去と縦になっていて、3次フィッティングがうまくいかない個体の除去"""        if tobjw >= 100 or tobjh >= 100:            c_img = img[tobjy:tobjy+tobjh, tobjx:tobjx+tobjw]            fname = fname + "_" + str(i) # ファイル名更新(元画像_オブジェクト番号.jpg)            l_img = c_img.copy()            bin_img = ip.binarization(l_img) # ここら辺二度手間感            #cv2.imwrite(f"bin_images/{fname}.jpg", bin_img)            bin_img = ip.morphology(bin_img)            #cv2.imwrite(f"mono/{fname}.jpg", bin_img)                        """ 一次関数フィッティング """            nLabels, labelImages, data, center = cv2.connectedComponentsWithStats(bin_img)            for j in range(1,nLabels,1): # ラベル数を取得 ＊背景である0を除く                target_lb_id = j # ターゲットID                tobjx = data[target_lb_id, 0] # (対象の)x座標                tobjy = data[target_lb_id, 1] # (対象の)y座標                tobjw = data[target_lb_id, 2] # (対象の)幅                if tobjw < 10:                    continue                tobjh = data[target_lb_id, 3] # (対象の)長さ(高さ)                h, w = l_img.shape[:2] # (画像の)大きさ                btarget = np.zeros((h, w), np.uint8) # ターゲット描画用に空画像を生成                res = np.zeros((h, w), np.uint8)                res = cv2.merge((res,res,res))                btarget[labelImages == target_lb_id] = 255 # ターゲットを取得する                                ypts, xpts = np.where(btarget == 255) # オブジェクトのある座標を取得                rv = np.polyfit(xpts ,ypts, 1) # 1次回帰                expr = np.poly1d(rv)                for x in np.arange(tobjx, tobjx+tobjw,0.1):                    v = expr(x)                    if(v > len(labelImages)-1): # 最大値処理                        v = len(labelImages)-1                    if x == tobjx:                        by = v                        bx = x                    elif  x != tobjx:                        by = v                        bx = x                                                cv2.line(res, (int(x), int(v)), (int(bx), int(by)), (255,255,255), 5)   # 曲線描画             """ 回転 """            edges = cv2.Canny(res,100,255,apertureSize = 3) # あまりに検知できない場合にはここを見直す            # 輪郭抽出画像保存用(基本的にデバック)            # cv2.imwrite(f"edge/{fname}.jpg", edges)            minLineLength = 100            maxLineGap = 5            # 画像内の直線を取得 #            lines = cv2.HoughLinesP(edges,1,np.pi/180,50,minLineLength,maxLineGap)                    sum_arg = 0            count_arg = 0            HORIZONTAL = 0            try:                for line in lines:                                # 直線の角度の平均を算出 #                        for x1,y1,x2,y2 in line:                        # 直線の角度を算出 #                        arg = math.degrees(math.atan2((y2-y1), (x2-x1)))                        # print("arg=",arg)                        HORIZONTAL = 0                        DIFF = 10 # 許容誤差 -> -10 - +10 を本来の水平線と考える                                                """ 平均以上の長さの線であれば                        　　 => これによってメインの線以外の影響を排除する                        """                        #if length > ave_len:                        # デバッグ用(抽出した直線成分の描画を行う)                        # これをONにしたまま実行すると長さを測定する時にバグが生じてしまうので、普段はOFF                        #l_img = cv2.line(l_img, (x1,y1), (x2,y2), (255,255,255), 3)                        # 許容誤差以上であれば角度を算出 #                        if not (arg > HORIZONTAL - DIFF and arg < HORIZONTAL + DIFF) :                            sum_arg += arg                            count_arg += 1                                        except Exception: # 直線成分がないとき => あまりにも多発する際にはedges内のthresholdを見直す                logging.error(f"{fname}において直線成分が検出できません")                cv2.imwrite(f"rotate_images/{fname}.jpg", l_img)                return l_img    if count_arg == 0:        cv2.imwrite(f"rotate_images/{fname}.jpg", l_img)        return l_img        else:        l_img = ndimage.rotate(l_img, (sum_arg / count_arg)) # 画像を回転        cv2.imwrite(f"rotate_images/{fname}.jpg", l_img)        return l_img;    